# DMP Router
# Handles uploading CSV files, retrieving prognosis values,
# running DMP analysis tasks, and managing results
from fastapi import APIRouter, File, Form, HTTPException, UploadFile
from fastapi.responses import FileResponse

from app.config import cnf
from app.schemas import (
    CSVUploadResponse,
    DMPRequest,
    DMPResponse,
    PrognosisValuesResponse,
    TaskStatus,
)
from app.services.dmp_run import DmpRunService
from app.services.get_task_status import get_celery_task_status
from app.services.prognosis_values_from_csv import get_prognosis_values_from_csv
from app.services.service_upload_beta_csv import UploadBetaValuesCSVService

PREFIX = cnf.prefix_dmp  # "dmp" by default

router = APIRouter(prefix="/dmp", tags=["Differential Methylation Analysis"])

upload_service = UploadBetaValuesCSVService(cnf.dmp_workdir)
dmp_run_service = DmpRunService(cnf.dmp_workdir)


@router.post("/upload", response_model=CSVUploadResponse)
async def upload_csv_file(
    file: UploadFile = File(..., description="Upload a CSV file with Prognosis column"),
    id: str = Form(None),  # Optional SHA1 hash from frontend
):
    return await upload_service.handle_upload(file, id)


@router.get("/exists/{sha1_hash}")
async def check_file_exists(sha1_hash: str):
    """Check if a file with the given SHA1 hash exists."""
    storage_dir = cnf.dmp_workdir / sha1_hash
    exists = storage_dir.exists() and any(storage_dir.iterdir())
    return {"sha1_hash": sha1_hash, "exists": exists}


@router.get("/status/{task_id}", response_model=TaskStatus)
async def get_task_status(task_id: str):
    """Get the status of a prognosis analysis task."""
    return get_celery_task_status(task_id)


@router.get("/prognosis-values/{sha1_hash}", response_model=PrognosisValuesResponse)
async def get_prognosis_values(sha1_hash: str):
    """Get unique values from the Prognosis column of the uploaded CSV file."""
    return get_prognosis_values_from_csv(sha1_hash)


@router.post("/run-dmp", response_model=DMPResponse)
async def run_dmp(request: DMPRequest):
    # High-level orchestration: delegate to service
    return await dmp_run_service.start(request)


@router.get("/results/{sha1_hash}")
async def list_results(sha1_hash: str):
    """List all algorithm result files for a given SHA1 hash."""
    storage_dir = cnf.dmp_workdir / sha1_hash / "out"

    if not storage_dir.exists():
        raise HTTPException(status_code=404, detail="Directory not found")

    # Look for result files (CSV files that are not the original)
    result_files = list(storage_dir.glob("*.csv"))

    results = []
    for result_file in result_files:
        results.append(
            {
                "filename": result_file.name,
                "file_size": result_file.stat().st_size,
                "created_time": result_file.stat().st_ctime,
                "download_url": f"{PREFIX}/download/{sha1_hash}/{result_file.name}",
            }
        )

    return {"sha1_hash": sha1_hash, "result_count": len(results), "results": results}


@router.get("/download/{sha1_hash}/{filename}")
async def download_result_file(sha1_hash: str, filename: str):
    """Download a result file."""

    file_path = cnf.dmp_workdir / sha1_hash / "out" / filename

    if not file_path.exists():
        raise HTTPException(status_code=404, detail="File not found")

    return FileResponse(path=str(file_path), filename=filename, media_type="text/csv")


@router.get("/images/{sha1_hash}")
async def get_generated_images(sha1_hash: str):
    """Get list of generated PNG images from the out directory."""
    # PNG images are generated by IDAT processing and stored in uploads/sha1/out
    # uploads_dir = cnf.bval_workdir
    storage_dir = cnf.dmp_workdir / sha1_hash / "out"

    if not storage_dir.exists():
        return {"sha1_hash": sha1_hash, "image_count": 0, "images": []}

    images = []
    for image_file in storage_dir.glob("*.png"):
        images.append(
            {
                "filename": image_file.name,
                "file_size": image_file.stat().st_size,
                "created_time": image_file.stat().st_ctime,
                "image_url": f"/dmp/image/{sha1_hash}/{image_file.name}",
            }
        )

    # Sort images by filename for consistent ordering
    images.sort(key=lambda x: x["filename"])

    return {"sha1_hash": sha1_hash, "image_count": len(images), "images": images}


@router.get("/image/{sha1_hash}/{filename}")
async def serve_generated_image(sha1_hash: str, filename: str):
    """Serve a generated PNG image."""

    # PNG images are generated by IDAT processing and stored in uploads/sha1/out
    storage_dir = cnf.dmp_workdir / sha1_hash / "out"
    image_path = storage_dir / filename

    if not image_path.exists() or not image_path.suffix.lower() == ".png":
        raise HTTPException(status_code=404, detail="Image not found")

    return FileResponse(path=str(image_path), filename=filename, media_type="image/png")
